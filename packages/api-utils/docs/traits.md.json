[["version", 2], ["markdown", "<!-- contributed by Irakli Gozalishvil [gozala@mozilla.com]  -->\n\nThe `traits` module provides base building blocks for secure object\ncomposition. It exports base trait / constructor function that\nconstructs an instance of `Trait`.\n\nTraits\n------\n\n[Traits] are a simple composition mechanism for structuring object-oriented\nprograms. Traits are similar to [interfaces], except that they often define\nonly a part of an object's data and behavior and are intended to be used in\nconjunction with other traits to completely define the object.\n\nTraits are also considered to be a more robust alternative to [mixins]\nbecause, name conflicts have to be resolved explicitly by composer & because\ntrait composition is order-independent (hence more declarative).\n\n\nThere are some other implementations of traits in JavaScript & some ideas /\nAPIs are borrowed from them:\n\n- [traitsjs]\n- [joose]\n\nObject-capability security model\n--------------------------------\n\nImplementation uses an [object-capability security model] to allow protection\nof private APIs. At the same private APIs can be shared between among trait\ncomposition parties. To put it simply: All the properties whose names start\nwith `\"_\"` are considered to be **private**, and are unaccessible from anywhere\nexcept other **public** methods / accessors of the instance that had been\ndefined during composition.\n\n\n[object-capability security model]:http://en.wikipedia.org/wiki/Object-capability_model\n[traitsjs]:http://www.traitsjs.org/\n[joose]:http://code.google.com/p/joose-js/\n[Traits]:http://en.wikipedia.org/wiki/Trait_%28computer_science%29\n[interfaces]:http://en.wikipedia.org/wiki/Interface_%28object-oriented_programming%29\n[mixins]:http://en.wikipedia.org/wiki/Mixins\n\n"], ["api-json", {"line_number": 44, "name": "Trait", "constructors": [{"line_number": 46, "signature": "Trait()", "type": "constructor", "name": "Trait", "description": "Creates an instance of Trait and returns it if it has no `constructor` method\ndefined. If instance has `constructor` method, then it is called with all the\narguments passed to this function and returned value is returned instead,\nunless it's `undefined`. In that case instance is returned.\n\n`Trait` function represents a base trait. As with any other trait it represents\na constructor function for creating instances of its own & a placeholder\nfor a trait compositions functions."}], "methods": [{"line_number": 58, "name": "compose", "returns": {"line_number": 114, "type": "Function", "description": "New trait containing the combined properties of all the traits."}, "params": [{"line_number": 107, "required": true, "type": "Object|Function", "name": "trait1", "description": "Trait or property map to compose new trait from."}, {"line_number": 109, "required": true, "type": "Object|Function", "name": "trait2", "description": "Trait or property map to compose new trait from."}, {"line_number": 111, "required": true, "type": "Object|Function", "name": "...", "description": "Traits or property maps to compose new trait from.\n"}], "signature": "compose(trait1, trait2, ...)", "type": "method", "description": "Composes new trait out of itself and traits / property maps passed as an\narguments. If two or more traits / property maps have properties with the same\nname, the new trait will contain a \"conflict\" property for that name (see\nexamples in Examples section to find out more about \"conflict\" properties).\nThis is a commutative and associative operation, and the order of its\narguments is not significant.\n\n**Examples:**\n\nLet's say we want to define a reusable piece of code for a lists of elements.\n\n    const { Trait } = require('traits');\n    const List = Trait.compose({\n      // private API:\n      _list: null,\n      // public API\n      constructor: function List() this._list = [],\n      get length() this._list.length,\n      add: function add(item) this._list.push(item),\n      remove: function remove(item) {\n        let list = this._list;\n        let index = list.indexOf(item);\n        if (0 <= index) list.slice(index, 1);\n      }\n    });\n\nInstances of `List` can be created by calling `List` function with or without\n`new` keyword.\n\n    let l1 = List();\n    l1 instanceof List;      // true\n    let l2 = new List();\n    l2 instanceof List;      // true\n\nAs you can see `add` and `remove` functions are capable of accessing private\n`_list` property, but thats about it, there's nothing else that will be able\nto access this property:\n\n    '_list' in l1;              // false\n    '_list' in l2;              // false\n    '_list' in List.protoype;   // false\n    l1.has = function(name) name in this\n    l1.has('_list');            // false\n    l1.length;                  // 0\n    l1.add('test')\n    l1.length                   // 1\n"}, {"line_number": 146, "name": "resolve", "returns": {"line_number": 185, "type": "Function", "description": "New resolved trait."}, "params": [{"line_number": 184, "required": true, "type": "Object", "name": "resolutions", "description": ""}], "signature": "resolve(resolutions)", "type": "method", "description": "Composes a new trait that has all the same properties\nas the trait on which it is called, except that each property listed\nin the `resolutions` argument will be renamed from the name\nof the  property in the `resolutions` argument to its value.\nAnd if its value is `null`, the property will become required.\n\n**Example:**\n\n    const Range = List.resolve({\n      constructor: null,\n      add: '_add',\n    }).compose({\n      min: null,\n      max: null,\n      get list() this._list.slice(0),\n      constructor: function Range(min, max) {\n        this.min = min;\n        this.max = max;\n        this._list = [];\n      },\n      add: function(item) {\n        if (item <= this.max && item >= this.min)\n          this._add(item)\n      }\n    });\n\n\n    let r = Range(0, 10);\n    r.min;                      // 0\n    r.max;                      // 10\n    r.length;                   // 0;\n    r.add(5);\n    r.length;                   // 1\n    r.add(12);\n    r.length;                   // 1 (12 was not in a range)\n"}, {"line_number": 189, "name": "override", "returns": {"line_number": 218, "type": "Function", "description": "New trait containing the combined properties of all the traits."}, "params": [{"line_number": 211, "required": true, "type": "Object|Function", "name": "trait1", "description": "Trait or property map to compose new trait from."}, {"line_number": 213, "required": true, "type": "Object|Function", "name": "trait2", "description": "Trait or property map to compose new trait from."}, {"line_number": 215, "required": true, "type": "Object|Function", "name": "...", "description": "Traits or property maps to compose new trait from.\n"}], "signature": "override(trait1, trait2, ...)", "type": "method", "description": "Composes a new trait with all of the combined properties of `this` and the\nargument traits. In contrast to `compose`, `override` immediately resolves\nall conflicts resulting from this composition by overriding the properties of\nlater traits. Trait priority is from left to right. I.e. the properties of\nthe leftmost trait are never overridden.\n\n**Example:**\n\n    // will compose trait with conflict property 'constructor'\n    var ConstructableList = List.compose({\n      constructor: function List() this._list = Array.slice(arguments)\n    });\n    // throws error with message 'Remaining conflicting property: constructor'\n    ConstructableList(1, 2, 3);\n\n    var ConstructableList = List.overridden({\n      constructor: function List() this._list = Array.slice(arguments)\n    });\n    ConstructableList(1, 2, 3).length       // 3\n"}, {"line_number": 228, "signature": "toString()", "type": "method", "name": "toString", "description": "Textual representation of an object. All the traits will return:\n`'[object Trait]'` string, unless they have `constructor` property, in that\ncase string `'Trait'` is replaced with the name of `constructor` property.\n\n**Example:**\n\n    const MyTrait = Trait.compose({\n      constructor: function MyTrait() {\n        // do your initialization here\n      }\n    });\n    MyTrait().toString();     // [object MyTrait]\n"}], "type": "class", "properties": [{"line_number": 118, "property_type": "Object", "type": "property", "name": "required", "description": "Singleton, used during trait composition to define \"required\" properties.\n\n**Example:**\n\n    const Enumerable = Trait.compose({\n      list: Trait.required,\n      forEach: function forEach(consumer) {\n        return this.list.forEach(consumer);\n      }\n    });\n\n    let c1 = Enumerable();      // Error: Missing required property: list\n\n    const EnumerableList = List.compose({\n      get list: this._list.slice(0)\n    }, Enumerable);\n\n    let c2 = EnumerableList();\n    c2.add('test')\n    c2.length                   // 1\n    c2.list[0]                  // 'test'\n    c2.forEach(console.log)     // > info: 'test'\n"}, {"line_number": 222, "property_type": "Object", "type": "property", "name": "_public", "description": "Internal property of instance representing public API that is exposed to the\nconsumers of an instance."}], "description": "\n\n\n\n\n\n"}], ["markdown", "\n"]]