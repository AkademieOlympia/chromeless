[["version", 2], ["markdown", "`nsJetpack` is a binary component used to provide services\nthat aren't otherwise available to scripted chrome code in the Mozilla\nplatform.\n\n## Accessing the Component ##\n\nSimply call `require(\"nsjetpack\").get()`. Note that an exception may be\nthrown if the component isn't available for the host operating system\nand application binary interface.\n\n## Sample Code ##\n\nSample code for `nsJetpack` can be found in its [test suite].\n\n  [test suite]: packages/nsjetpack/tests/test-legacy-nsjetpack.js\n\n## Flexible Membrane Functionality ##\n\n`nsJetpack` contains functionality that exposes many\nSpiderMonkey C API calls to JavaScript, allowing chrome code to create\ncustom membranes (aka wrappers) that allow trusted and untrusted code\nto interoperate.\n\nAside from security, however, this functionality can also be used to\nimplement APIs that can't normally be implemented using the JavaScript\nlanguage, such as the `window.localStorage` interface in\nHTML5.\n\nThe source code for this functionality is in [wrapper.cpp].\n\n  [wrapper.cpp]: packages/nsjetpack/components/src/wrapper.cpp\n\n### Security Concerns ###\n\nNote that the Flexible Membrane functionality is intended primarily\nfor prototyping purposes; its use is discouraged in production code\nfor two reasons:\n\n* The membrane methods have a tendency to get called very frequently,\n  and as a result, implementing them in JavaScript is likely to not be\n  efficient.\n\n* JavaScript is an inherently dynamic language, and it's very hard to\n  predict what all the possible outcomes of JavaScript code for a\n  membrane might be&mdash;especially when the membrane's script is in\n  the same `JSRuntime` as the code it's trying to protect.\n  Because of this, it's hard to code review a Flexible Membrane for\n  security vulnerabilities.\n\n* Because of these concerns, it's advised that any flexible membranes\n  be re-written in C++ before being reviewed for security and placed\n  in production code.  Before being re-written, however, a test suite\n  should be created for the membrane to ensure that its new\n  implementation has the same characteristics as the original.\n\n### Functions ###\n\n<code>nsJetpack.**wrap**(*wrappee*, *membrane*)</code>\n\nThis function wraps *wrappee* with the *membrane* (meaning that\n*membrane* mediates all access to and from *wrappee*).  The wrapped\nobject is returned.\n\n<code>nsJetpack.**unwrap**(*wrappedObject*)</code>\n\nRemoves the membrane from *wrappedObject* and returns the wrappee. If\n*wrappedObject* wasn't ever wrapped by *nsJetpack.*`wrap()`,\nthis function returns `null`.\n\n<code>nsJetpack.**getWrapper**(*wrappedObject*)</code>\n\nReturns the membrane for the given *wrappedObject*. If *wrappedObject*\nwasn't ever wrapped by *nsJetpack.*`wrap()`, this function\nreturns `null`.\n\n### Membrane Objects ###\n\nA *membrane object* is a user-defined JavaScript object with any of\nthe following optional methods defined.\n\nNote that for all of these methods, `this` is set to the\ninstance of the membrane whose method is being called.\n\n<code>membrane.**call**(*wrappee*, *wrappedObject*, *thisObj*, *args*)</code>\n\nThis is essentially a JavaScript version of <code>[JSClass.call]</code>;\nalternatively, it could be described as the analog of Python's\n`__call__` magic method.  *thisObj* is the object that the\ncallee's `this` variable should be set to, and *args* is the\narray of arguments to be passed to the callee.  This method should\nreturn whatever the return value of the callee is, or raise an\nexception.\n\n  [JSClass.call]: https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JSClass.call\n\n<code>membrane.**construct**(*wrappee*, *wrappedObject*, *thisObj*, *args*)</code>\n\nThis is essentially a JavaScript version of\n<code>[JSClass.construct]</code>.  It's just like\n*membrane.*`call()`, only it's called when the call is preceded\nby the `new` operator.\n\n  [JSClass.construct]: https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JSClass.construct\n\n`membrane.`**convert**(*wrappee*, *wrappedObject*, *type*)\n\nThis is essentially a JavaScript version of\n<code>[JSClass.convert]</code>, and is called when SpiderMonkey needs to\ncoerce *wrappee* to a different type.  *type* is a string identifying\nthe name of the desired type to coerce to, and can be anything\nordinarily returned by JavaScript's *typeof* operator.  The default\nimplementation of this is to call *wrappee.*`valueOf()`.\n\n**NOTE:** Be very careful about implementing this function, as it can\neasily cause infinite recursion.\n\n  [JSClass.convert]: https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JSClass.convert\n\n<code>membrane.**resolve**(*wrappee*, *wrappedObject*, *name*)</code>\n\nThis is essentially a JavaScript version of\n<code>[JSClass.resolve]</code>.  It's called when the property identified\nby *name* doesn't exist on *wrappedObject*.  The membrane should\neither define *name* on *wrappedObject* and return *wrappedObject*,\nor&mdash;if *name* doesn't exist&mdash;it should return\n`undefined`.\n\n  [JSClass.resolve]: https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JSClass.resolve\n\n<code>membrane.**enumerate**(*wrappee*, *wrappedObject*)</code>\n\nThis is essentially a JavaScript version of\n<code>[JSClass.enumerate]</code>.  It should return an iterator that\niterates through all the property names in *wrappee*.\n\n  [JSClass.enumerate]: https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JSClass.enumerate\n\n<code>membrane.**iteratorObject**(*wrappee*, *wrappedObject*, *keysOnly*)</code>\n\nThis is essentially a JavaScript version of\n<code>[JSExtendedClass.iteratorObject]</code>.  If *keysOnly* is\n`true`, it should return an iterator that iterates through all\nthe property names in *wrappee*.  Otherwise, it should return an\niterator that yields key-value pairs (in an `Array` object).\n\n  [JSExtendedClass.iteratorObject]: https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JSExtendedClass.iteratorObject\n\n<code>membrane.**getProperty**(*wrappee*, *wrappedObject*, *name*, *defaultValue*)</code>\n\nThis is essentially a JavaScript version of\n<code>[JSClass.getProperty]</code>; alternatively, it could be described\nas the analog of Python's `__getattr__` magic method. *name* is\nthe name of the property being accessed, and *defaultValue* is the\nvalue that JavaScript would ordinarily return.  This function should\nreturn the value of the property, which may be *defaultValue* or\nsomething different. Alternatively, the method may also throw an\nexception.\n\n  [JSClass.getProperty]: https://developer.mozilla.org/En/SpiderMonkey/JSAPI_Reference/JSPropertyOp\n\n<code>membrane.**setProperty**(*wrappee*, *wrappedObject*, *name*, *defaultValue*)</code>\n\nThis is essentially a JavaScript version of\n<code>[JSClass.setProperty]</code>; alternatively, it could be described\nas the analog of Python's `__setattr__` magic method. *name* is\nthe name of the property being accessed, and *defaultValue* is the\nvalue that JavaScript would ordinarily set the value of the property\nto.  This function should return the value to set the property to,\nwhich may be *defaultValue* or something different. Alternatively, the\nmethod may also throw an exception.\n\n  [JSClass.setProperty]: https://developer.mozilla.org/En/SpiderMonkey/JSAPI_Reference/JSPropertyOp\n\n<code>membrane.**addProperty**(*wrappee*, *wrappedObject*, *name*, *defaultValue*)</code>\n\nThis is essentially a JavaScript version of\n<code>[JSClass.addProperty]</code>, and is called immediately after a new\nproperty has been added to *wrappedObject*. *name* is the name of the\nproperty being accessed, and *defaultValue* is the value that\nJavaScript would ordinarily set the initial value of the property to.\nThis function should return the initial value to set the property to,\nwhich may be *defaultValue* or something different. Alternatively, the\nmethod may also throw an exception.\n\n  [JSClass.addProperty]: https://developer.mozilla.org/En/SpiderMonkey/JSAPI_Reference/JSPropertyOp\n\n<code>membrane.**delProperty**(*wrappee*, *wrappedObject*, *name*)</code>\n\nThis is essentially a JavaScript version of\n<code>[JSClass.delProperty]</code>; alternatively, it could be described\nas the analog of Python's `__delattr__` magic method. *name* is\nthe name of the property being deleted.  This function should return\n`true` if the property can be deleted, and `false` if\nnot.\n\n  [JSClass.delProperty]: https://developer.mozilla.org/En/SpiderMonkey/JSAPI_Reference/JSPropertyOp\n\n## Memory Profiling ##\n\n`nsJetpack` contains functionality allowing chrome code to\nexamine the JavaScript heap. The semantics of this are described at a\nhigh level in Atul's blog post entitled [Fun with SpiderMonkey];\nplease read this blog post before reading the rest of this section.\n\nThe source code for this functionality is in [memory_profiler.cpp].\n\n  [Fun with SpiderMonkey]: http://www.toolness.com/wp/?p=604\n  [memory_profiler.cpp]: packages/nsjetpack/components/src/memory_profiler.cpp\n\n### Functions ###\n\n<code>nsJetpack.**profileMemory**(*code*, *filename*, *lineNumber*, *namedObjects*, *argument*)</code>\n\nThis function launches a memory profiling JS runtime and executes\n*code* in it. The *filename* and *lineNumber* information is for error\nreporting purposes only.\n\n*namedObjects* is an optional object whose properties, called \"names\",\npoint to objects in the target JS runtime; these objects can be\nreferred to by their names by certain functions in the memory\nprofiling JS runtime.\n\n*argument* is an optional string that will be copied into the\nprofiling JS runtime as a global variable of the same name. This\nallows the target JS runtime to pass execution parameters (serialized\nas a JSON string, perhaps) into the profiling JS runtime.\n\nIf the final statement of *code* results in a string value, this value\nis copied and passed back as the result of this function.  This allows\n*code* to perform some memory profiling activity and return the\nresults back to the target JS runtime.\n\n### Memory Profiling Globals ###\n\nCode running in the memory profiling JS runtime has access to the\nfollowing global objects and functions.\n\n<code>**ServerSocket**()</code>\n\nThis constructor creates a new blocking TCP/IP socket, aka\n`ServerSocket`.\n\n<code>**getGCRoots**()</code>\n\nReturns an array of the numeric JavaScript object IDs of the target\nruntime that are garbage collection roots.\n\n<code>**getObjectTable**()</code>\n\nReturns an object whose keys are object IDs and whose values are the\nname of the `JSClass` used by the object for each ID.  This is\neffectively an index into all objects in the target runtime.\n\n<code>**getObjectInfo**(*idOrName*)</code>\n\nReturns a JSON-able object containing metadata for the object in the target runtime with the given numeric ID or string name. The object may contain any of the following keys:\n\n`id` - The numeric ID of the object.\n\n`nativeClass` - The name of the `JSClass` used by the object.\n\n`size` - The size of the object, as reported by\n`JS_GetObjectTotalSize()`.\n\n`parent` - The object's `__parent__` property (i.e., its global scope).\n\n`prototype` - The object's `__proto__` property.\n\n`wrappedObject` - The object ID of the object that this object wraps.\n\n`outerObject` - The object ID for this object's outer half, if\nit's the inner half of a [split object].\n\n`innerObject` - The object ID for this object's inner half, if\nit's the outer half of a [split object].\n\n  [split object]: https://developer.mozilla.org/En/SpiderMonkey/Split_object\n\n`children` - An array of object IDs corresponding to all the\nobjects that this object references.  Note that these aren't really\n\"children\" in a hierarchical sense, but rather in a heap-tracing\nsense.\n\n`functionSize` - If this object corresponds to a function, this\nis the value returned by `JS_GetFunctionTotalSize()` on the\nobject.\n\n`scriptSize` - If this object corresponds to a function, this\nis the value returned by `JS_GetScriptTotalSize()` on the\nobject.\n\n`name` - If this object corresponds to a function, this is the\nfunction's name.\n\n`filename` - If this object corresponds to a function, this is\nthe filename in which the function is defined.\n\n`lineStart` - If this object corresponds to a function, this is\nthe line at which the function's code begins.\n\n`lineEnd` - If this object corresponds to a function, this is\nthe line at which the function's code ends.\n\n<code>**getObjectParent**(*idOrName*)</code>\n\nReturns the object ID of the object with the given numeric ID or\nstring name. If the object has no parent, `null` is returned.\n\n<code>**getObjectProperties**(*idOrName*, *useAlternateAlgorithm*)</code>\n\nReturns a list of the properties on the given object, which doesn't\ninclude properties of the object's prototype.  If\n*useAlternateAlgorithm* is true, a different JSAPI call will be used\nto obtain the properties.  This function has a tendency to\ninadvertently execute code on the target runtime, so be very careful\nwhat objects you call this on.\n\n<code>**getNamedObjects**()</code>\n\nReturns a JSON-able object containing a mapping of names to numeric\nobject IDs; this is the \"mirror\" of the *namedObjects* parameter\npassed to *nsJetpack.*`profileMemory()` in the memory profiling\nruntime.\n\n<code>**stack**()</code>\n\nReturns a `StackFrame` object corresponding to the current\nstate of the memory profiling runtime's stack.\n\n<code>**lastException**</code>\n\nThis global variable contains a reference to the most recently-thrown\nexception in the memory profiling runtime.\n\n<code>**lastExceptionTraceback**</code>\n\nThis global variable contains a reference to the `StackFrame`\nof the most recently-thrown exception in the memory profiling runtime.\n\n**argument**\n\nThis global variable is a copy of the *argument* parameter passed to\n*nsJetpack.*`profileMemory()` in the memory profiling runtime.\n\n### StackFrame Objects ###\n\n<code>StackFrame.**filename**</code>\n\nThe filename of the stack frame.\n\n<code>StackFrame.**lineNo**</code>\n\nThe line number of the stack frame.\n\n<code>StackFrame.**functionName**</code>\n\nThe function in which the stack frame is taking place.\n\n<code>StackFrame.**functionObject**</code>\n\nA reference to the function object in which the stack frame is taking\nplace.\n\n<code>StackFrame.**scopeChain**</code>\n\nA reference to the scope chain of the stack frame.\n\n<code>StackFrame.**caller**</code>\n\nA reference to the `StackFrame` of this stack frame's\ncaller. If this stack frame doesn't have a caller, the property is\n`undefined`.\n\n### ServerSocket Objects ###\n\n<code>ServerSocket.**bind**(*ip*, *port*)</code>\n\nBinds the socket to the given *ip* and *port*.\n\n<code>ServerSocket.**listen**()</code>\n\nConfigures the socket for listening.\n\n<code>ServerSocket.**accept**()</code>\n\nBlocks until a connection is made on the socket and returns a new\n`ServerSocket` object representing the new connection.\n\n<code>ServerSocket.**recv**(*size*)</code>\n\nReceives up to *size* bytes of text from the connected client and\nreturns it as a string. If the connection has been closed,\n`null` is returned instead.\n\n<code>ServerSocket.**send**(*text*)</code>\n\nSends the given text to the connected client.\n\n<code>ServerSocket.**close**()</code>\n\nCloses the connection.\n\n## Miscellaneous Functions ##\n\nThe source code for this functionality is in [tcb.cpp].\n\n  [tcb.cpp]: packages/nsjetpack/components/src/tcb.cpp\n\n<code>nsJetpack.**functionInfo**(*func*)</code>\n\nReturns a JSON-able object with the following properties:\n\n`filename` - The filename in which *func* is defined.\n\n`lineNumber` - The line number at which *func* is defined.\n\n<code>nsJetpack.**seal**(*object*, *isDeep*)</code>\n\nThis is essentially a JavaScript version of <code>[JS_SealObject]</code>.\n\n  [JS_SealObject]: https://developer.mozilla.org/en/SpiderMonkey/JSAPI_Reference/JS_SealObject\n\nNote that according to the documentation for `JS_SealObject`\nand [John Resig's post on Ecmascript 5], this actually appears to be\nmore similar to ES5's `Object.freeze()` than it is to ES5's\n`Object.seal()`.\n\n  [John Resig's post on Ecmascript 5]: http://ejohn.org/blog/ecmascript-5-objects-and-properties/\n"]]