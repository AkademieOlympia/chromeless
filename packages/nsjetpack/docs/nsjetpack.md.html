
<!DOCTYPE html>

<html>

<head>

  <meta http-equiv="Content-type" content="text/html; charset=utf-8" />

  <base target="_blank"/>

  <link rel="stylesheet" type="text/css" media="all"

        href="../../../css/base.css" />

  <link rel="stylesheet" type="text/css" media="all"

        href="../../../css/apidocs.css" />

  <title>Add-on SDK Documentation</title>

  <style type="text/css">

    body {

      border: 50px solid #FFFFFF;

    }

  </style>



  <script type="text/javascript">

    function rewrite_links() {

      var images = document.getElementsByTagName("img");

      for (var i = 0; i < images.length; i++) {

        var before = images[i].src.split("packages/")[0];

        var after = images[i].src.split("/docs")[1];

        images[i].src = before + after;

      }

    }

    </script>

</head>



<body onload = "rewrite_links()">

<div id="nsjetpack_module_api_docs" class="module_api_docs">
  
  <h1>nsjetpack</h1>
  <div class="module_description">
    
    <p><code>nsJetpack</code> is a binary component used to provide services
    that aren't otherwise available to scripted chrome code in the Mozilla
    platform.</p>
    <h2>Accessing the Component</h2>
    <p>Simply call <code>require("nsjetpack").get()</code>. Note that an exception may be
    thrown if the component isn't available for the host operating system
    and application binary interface.</p>
    <h2>Sample Code</h2>
    <p>Sample code for <code>nsJetpack</code> can be found in its [test suite].</p>
    <h2>Flexible Membrane Functionality</h2>
    <p><code>nsJetpack</code> contains functionality that exposes many
    SpiderMonkey C API calls to JavaScript, allowing chrome code to create
    custom membranes (aka wrappers) that allow trusted and untrusted code
    to interoperate.</p>
    <p>Aside from security, however, this functionality can also be used to
    implement APIs that can't normally be implemented using the JavaScript
    language, such as the <code>window.localStorage</code> interface in
    HTML5.</p>
    <p>The source code for this functionality is in [wrapper.cpp].</p>
    <h3>Security Concerns</h3>
    <p>Note that the Flexible Membrane functionality is intended primarily
    for prototyping purposes; its use is discouraged in production code
    for two reasons:</p>
    <ul>
    <li>
    <p>The membrane methods have a tendency to get called very frequently,
      and as a result, implementing them in JavaScript is likely to not be
      efficient.</p>
    </li>
    <li>
    <p>JavaScript is an inherently dynamic language, and it's very hard to
      predict what all the possible outcomes of JavaScript code for a
      membrane might be&mdash;especially when the membrane's script is in
      the same <code>JSRuntime</code> as the code it's trying to protect.
      Because of this, it's hard to code review a Flexible Membrane for
      security vulnerabilities.</p>
    </li>
    <li>
    <p>Because of these concerns, it's advised that any flexible membranes
      be re-written in C++ before being reviewed for security and placed
      in production code.  Before being re-written, however, a test suite
      should be created for the membrane to ensure that its new
      implementation has the same characteristics as the original.</p>
    </li>
    </ul>
    <h3>Functions</h3>
    <p><code>nsJetpack.<strong>wrap</strong>(<em>wrappee</em>, <em>membrane</em>)</code></p>
    <p>This function wraps <em>wrappee</em> with the <em>membrane</em> (meaning that
    <em>membrane</em> mediates all access to and from <em>wrappee</em>).  The wrapped
    object is returned.</p>
    <p><code>nsJetpack.<strong>unwrap</strong>(<em>wrappedObject</em>)</code></p>
    <p>Removes the membrane from <em>wrappedObject</em> and returns the wrappee. If
    <em>wrappedObject</em> wasn't ever wrapped by <em>nsJetpack.</em><code>wrap()</code>,
    this function returns <code>null</code>.</p>
    <p><code>nsJetpack.<strong>getWrapper</strong>(<em>wrappedObject</em>)</code></p>
    <p>Returns the membrane for the given <em>wrappedObject</em>. If <em>wrappedObject</em>
    wasn't ever wrapped by <em>nsJetpack.</em><code>wrap()</code>, this function
    returns <code>null</code>.</p>
    <h3>Membrane Objects</h3>
    <p>A <em>membrane object</em> is a user-defined JavaScript object with any of
    the following optional methods defined.</p>
    <p>Note that for all of these methods, <code>this</code> is set to the
    instance of the membrane whose method is being called.</p>
    <p><code>membrane.<strong>call</strong>(<em>wrappee</em>, <em>wrappedObject</em>, <em>thisObj</em>, <em>args</em>)</code></p>
    <p>This is essentially a JavaScript version of <code>[JSClass.call]</code>;
    alternatively, it could be described as the analog of Python's
    <code>__call__</code> magic method.  <em>thisObj</em> is the object that the
    callee's <code>this</code> variable should be set to, and <em>args</em> is the
    array of arguments to be passed to the callee.  This method should
    return whatever the return value of the callee is, or raise an
    exception.</p>
    <p><code>membrane.<strong>construct</strong>(<em>wrappee</em>, <em>wrappedObject</em>, <em>thisObj</em>, <em>args</em>)</code></p>
    <p>This is essentially a JavaScript version of
    <code>[JSClass.construct]</code>.  It's just like
    <em>membrane.</em><code>call()</code>, only it's called when the call is preceded
    by the <code>new</code> operator.</p>
    <p><code>membrane.</code><strong>convert</strong>(<em>wrappee</em>, <em>wrappedObject</em>, <em>type</em>)</p>
    <p>This is essentially a JavaScript version of
    <code>[JSClass.convert]</code>, and is called when SpiderMonkey needs to
    coerce <em>wrappee</em> to a different type.  <em>type</em> is a string identifying
    the name of the desired type to coerce to, and can be anything
    ordinarily returned by JavaScript's <em>typeof</em> operator.  The default
    implementation of this is to call <em>wrappee.</em><code>valueOf()</code>.</p>
    <p><strong>NOTE:</strong> Be very careful about implementing this function, as it can
    easily cause infinite recursion.</p>
    <p><code>membrane.<strong>resolve</strong>(<em>wrappee</em>, <em>wrappedObject</em>, <em>name</em>)</code></p>
    <p>This is essentially a JavaScript version of
    <code>[JSClass.resolve]</code>.  It's called when the property identified
    by <em>name</em> doesn't exist on <em>wrappedObject</em>.  The membrane should
    either define <em>name</em> on <em>wrappedObject</em> and return <em>wrappedObject</em>,
    or&mdash;if <em>name</em> doesn't exist&mdash;it should return
    <code>undefined</code>.</p>
    <p><code>membrane.<strong>enumerate</strong>(<em>wrappee</em>, <em>wrappedObject</em>)</code></p>
    <p>This is essentially a JavaScript version of
    <code>[JSClass.enumerate]</code>.  It should return an iterator that
    iterates through all the property names in <em>wrappee</em>.</p>
    <p><code>membrane.<strong>iteratorObject</strong>(<em>wrappee</em>, <em>wrappedObject</em>, <em>keysOnly</em>)</code></p>
    <p>This is essentially a JavaScript version of
    <code>[JSExtendedClass.iteratorObject]</code>.  If <em>keysOnly</em> is
    <code>true</code>, it should return an iterator that iterates through all
    the property names in <em>wrappee</em>.  Otherwise, it should return an
    iterator that yields key-value pairs (in an <code>Array</code> object).</p>
    <p><code>membrane.<strong>getProperty</strong>(<em>wrappee</em>, <em>wrappedObject</em>, <em>name</em>, <em>defaultValue</em>)</code></p>
    <p>This is essentially a JavaScript version of
    <code>[JSClass.getProperty]</code>; alternatively, it could be described
    as the analog of Python's <code>__getattr__</code> magic method. <em>name</em> is
    the name of the property being accessed, and <em>defaultValue</em> is the
    value that JavaScript would ordinarily return.  This function should
    return the value of the property, which may be <em>defaultValue</em> or
    something different. Alternatively, the method may also throw an
    exception.</p>
    <p><code>membrane.<strong>setProperty</strong>(<em>wrappee</em>, <em>wrappedObject</em>, <em>name</em>, <em>defaultValue</em>)</code></p>
    <p>This is essentially a JavaScript version of
    <code>[JSClass.setProperty]</code>; alternatively, it could be described
    as the analog of Python's <code>__setattr__</code> magic method. <em>name</em> is
    the name of the property being accessed, and <em>defaultValue</em> is the
    value that JavaScript would ordinarily set the value of the property
    to.  This function should return the value to set the property to,
    which may be <em>defaultValue</em> or something different. Alternatively, the
    method may also throw an exception.</p>
    <p><code>membrane.<strong>addProperty</strong>(<em>wrappee</em>, <em>wrappedObject</em>, <em>name</em>, <em>defaultValue</em>)</code></p>
    <p>This is essentially a JavaScript version of
    <code>[JSClass.addProperty]</code>, and is called immediately after a new
    property has been added to <em>wrappedObject</em>. <em>name</em> is the name of the
    property being accessed, and <em>defaultValue</em> is the value that
    JavaScript would ordinarily set the initial value of the property to.
    This function should return the initial value to set the property to,
    which may be <em>defaultValue</em> or something different. Alternatively, the
    method may also throw an exception.</p>
    <p><code>membrane.<strong>delProperty</strong>(<em>wrappee</em>, <em>wrappedObject</em>, <em>name</em>)</code></p>
    <p>This is essentially a JavaScript version of
    <code>[JSClass.delProperty]</code>; alternatively, it could be described
    as the analog of Python's <code>__delattr__</code> magic method. <em>name</em> is
    the name of the property being deleted.  This function should return
    <code>true</code> if the property can be deleted, and <code>false</code> if
    not.</p>
    <h2>Memory Profiling</h2>
    <p><code>nsJetpack</code> contains functionality allowing chrome code to
    examine the JavaScript heap. The semantics of this are described at a
    high level in Atul's blog post entitled [Fun with SpiderMonkey];
    please read this blog post before reading the rest of this section.</p>
    <p>The source code for this functionality is in [memory_profiler.cpp].</p>
    <h3>Functions</h3>
    <p><code>nsJetpack.<strong>profileMemory</strong>(<em>code</em>, <em>filename</em>, <em>lineNumber</em>, <em>namedObjects</em>, <em>argument</em>)</code></p>
    <p>This function launches a memory profiling JS runtime and executes
    <em>code</em> in it. The <em>filename</em> and <em>lineNumber</em> information is for error
    reporting purposes only.</p>
    <p><em>namedObjects</em> is an optional object whose properties, called "names",
    point to objects in the target JS runtime; these objects can be
    referred to by their names by certain functions in the memory
    profiling JS runtime.</p>
    <p><em>argument</em> is an optional string that will be copied into the
    profiling JS runtime as a global variable of the same name. This
    allows the target JS runtime to pass execution parameters (serialized
    as a JSON string, perhaps) into the profiling JS runtime.</p>
    <p>If the final statement of <em>code</em> results in a string value, this value
    is copied and passed back as the result of this function.  This allows
    <em>code</em> to perform some memory profiling activity and return the
    results back to the target JS runtime.</p>
    <h3>Memory Profiling Globals</h3>
    <p>Code running in the memory profiling JS runtime has access to the
    following global objects and functions.</p>
    <p><code><strong>ServerSocket</strong>()</code></p>
    <p>This constructor creates a new blocking TCP/IP socket, aka
    <code>ServerSocket</code>.</p>
    <p><code><strong>getGCRoots</strong>()</code></p>
    <p>Returns an array of the numeric JavaScript object IDs of the target
    runtime that are garbage collection roots.</p>
    <p><code><strong>getObjectTable</strong>()</code></p>
    <p>Returns an object whose keys are object IDs and whose values are the
    name of the <code>JSClass</code> used by the object for each ID.  This is
    effectively an index into all objects in the target runtime.</p>
    <p><code><strong>getObjectInfo</strong>(<em>idOrName</em>)</code></p>
    <p>Returns a JSON-able object containing metadata for the object in the target runtime with the given numeric ID or string name. The object may contain any of the following keys:</p>
    <p><code>id</code> - The numeric ID of the object.</p>
    <p><code>nativeClass</code> - The name of the <code>JSClass</code> used by the object.</p>
    <p><code>size</code> - The size of the object, as reported by
    <code>JS_GetObjectTotalSize()</code>.</p>
    <p><code>parent</code> - The object's <code>__parent__</code> property (i.e., its global scope).</p>
    <p><code>prototype</code> - The object's <code>__proto__</code> property.</p>
    <p><code>wrappedObject</code> - The object ID of the object that this object wraps.</p>
    <p><code>outerObject</code> - The object ID for this object's outer half, if
    it's the inner half of a [split object].</p>
    <p><code>innerObject</code> - The object ID for this object's inner half, if
    it's the outer half of a [split object].</p>
    <p><code>children</code> - An array of object IDs corresponding to all the
    objects that this object references.  Note that these aren't really
    "children" in a hierarchical sense, but rather in a heap-tracing
    sense.</p>
    <p><code>functionSize</code> - If this object corresponds to a function, this
    is the value returned by <code>JS_GetFunctionTotalSize()</code> on the
    object.</p>
    <p><code>scriptSize</code> - If this object corresponds to a function, this
    is the value returned by <code>JS_GetScriptTotalSize()</code> on the
    object.</p>
    <p><code>name</code> - If this object corresponds to a function, this is the
    function's name.</p>
    <p><code>filename</code> - If this object corresponds to a function, this is
    the filename in which the function is defined.</p>
    <p><code>lineStart</code> - If this object corresponds to a function, this is
    the line at which the function's code begins.</p>
    <p><code>lineEnd</code> - If this object corresponds to a function, this is
    the line at which the function's code ends.</p>
    <p><code><strong>getObjectParent</strong>(<em>idOrName</em>)</code></p>
    <p>Returns the object ID of the object with the given numeric ID or
    string name. If the object has no parent, <code>null</code> is returned.</p>
    <p><code><strong>getObjectProperties</strong>(<em>idOrName</em>, <em>useAlternateAlgorithm</em>)</code></p>
    <p>Returns a list of the properties on the given object, which doesn't
    include properties of the object's prototype.  If
    <em>useAlternateAlgorithm</em> is true, a different JSAPI call will be used
    to obtain the properties.  This function has a tendency to
    inadvertently execute code on the target runtime, so be very careful
    what objects you call this on.</p>
    <p><code><strong>getNamedObjects</strong>()</code></p>
    <p>Returns a JSON-able object containing a mapping of names to numeric
    object IDs; this is the "mirror" of the <em>namedObjects</em> parameter
    passed to <em>nsJetpack.</em><code>profileMemory()</code> in the memory profiling
    runtime.</p>
    <p><code><strong>stack</strong>()</code></p>
    <p>Returns a <code>StackFrame</code> object corresponding to the current
    state of the memory profiling runtime's stack.</p>
    <p><code><strong>lastException</strong></code></p>
    <p>This global variable contains a reference to the most recently-thrown
    exception in the memory profiling runtime.</p>
    <p><code><strong>lastExceptionTraceback</strong></code></p>
    <p>This global variable contains a reference to the <code>StackFrame</code>
    of the most recently-thrown exception in the memory profiling runtime.</p>
    <p><strong>argument</strong></p>
    <p>This global variable is a copy of the <em>argument</em> parameter passed to
    <em>nsJetpack.</em><code>profileMemory()</code> in the memory profiling runtime.</p>
    <h3>StackFrame Objects</h3>
    <p><code>StackFrame.<strong>filename</strong></code></p>
    <p>The filename of the stack frame.</p>
    <p><code>StackFrame.<strong>lineNo</strong></code></p>
    <p>The line number of the stack frame.</p>
    <p><code>StackFrame.<strong>functionName</strong></code></p>
    <p>The function in which the stack frame is taking place.</p>
    <p><code>StackFrame.<strong>functionObject</strong></code></p>
    <p>A reference to the function object in which the stack frame is taking
    place.</p>
    <p><code>StackFrame.<strong>scopeChain</strong></code></p>
    <p>A reference to the scope chain of the stack frame.</p>
    <p><code>StackFrame.<strong>caller</strong></code></p>
    <p>A reference to the <code>StackFrame</code> of this stack frame's
    caller. If this stack frame doesn't have a caller, the property is
    <code>undefined</code>.</p>
    <h3>ServerSocket Objects</h3>
    <p><code>ServerSocket.<strong>bind</strong>(<em>ip</em>, <em>port</em>)</code></p>
    <p>Binds the socket to the given <em>ip</em> and <em>port</em>.</p>
    <p><code>ServerSocket.<strong>listen</strong>()</code></p>
    <p>Configures the socket for listening.</p>
    <p><code>ServerSocket.<strong>accept</strong>()</code></p>
    <p>Blocks until a connection is made on the socket and returns a new
    <code>ServerSocket</code> object representing the new connection.</p>
    <p><code>ServerSocket.<strong>recv</strong>(<em>size</em>)</code></p>
    <p>Receives up to <em>size</em> bytes of text from the connected client and
    returns it as a string. If the connection has been closed,
    <code>null</code> is returned instead.</p>
    <p><code>ServerSocket.<strong>send</strong>(<em>text</em>)</code></p>
    <p>Sends the given text to the connected client.</p>
    <p><code>ServerSocket.<strong>close</strong>()</code></p>
    <p>Closes the connection.</p>
    <h2>Miscellaneous Functions</h2>
    <p>The source code for this functionality is in [tcb.cpp].</p>
    <p><code>nsJetpack.<strong>functionInfo</strong>(<em>func</em>)</code></p>
    <p>Returns a JSON-able object with the following properties:</p>
    <p><code>filename</code> - The filename in which <em>func</em> is defined.</p>
    <p><code>lineNumber</code> - The line number at which <em>func</em> is defined.</p>
    <p><code>nsJetpack.<strong>seal</strong>(<em>object</em>, <em>isDeep</em>)</code></p>
    <p>This is essentially a JavaScript version of <code>[JS_SealObject]</code>.</p>
    <p>Note that according to the documentation for <code>JS_SealObject</code>
    and [John Resig's post on Ecmascript 5], this actually appears to be
    more similar to ES5's <code>Object.freeze()</code> than it is to ES5's
    <code>Object.seal()</code>.</p>
  </div>
  
  
</div>


</body>



</html>
